%{
#include <stdio.h>
#include <stdarg.h>
#include "bash.h"

/* some internal files generated by bison */
int yylex();
void yyerror(const char *s,...);
void yywarn(const char *s,...);

// data structure to hold a linked list of arguments for a command
struct args {
    char *arg;
    struct args *next;
};

#include <stdlib.h>
#include <string.h>
void *
MallocZ (int nbytes)
{
    char *ptr = malloc(nbytes);
    if (ptr == NULL)
	{
	    perror("malloc failed, fatal\n");
	    exit (66);
	}

	// initialize the space to all zeroes
    memset (ptr, '\00', nbytes);

    return (ptr);
}

// data structure to hold a linked list of redirections for a command
struct redirs {
    int redir_token;
	char *filename;
    struct redirs *next;
};


/* include debugging code, in case we want it */
#define YYDEBUG 1

int lines = 0;
static int synerrors = 0;


%}


%union	{ /* the types that we use in the tokens */
    char *string;
    struct command *pcmd;
    struct args *pargs;
    struct redirs *predir;
    int number;
}



%token EOLN PIPE 
%token INFILE					// standard input redirection
%token OUTFILE OUTFILE_APPEND	// standard output redirection
%token ERRFILE ERRFILE_APPEND	// standard error redirection
%token <string> WORD

%type <pcmd> line cmd	// main datatype from bash.h
%type <pargs> optargs arg
%type <predir> optredirs redir
  

%% 	/* beginning of the parsing rules	*/
input	: lines
	|
  	;

lines	: oneline
	| oneline lines
	;

oneline : line eoln
		{
			if (!synerrors) {
				doline($1);
				printPrompt();
			}
			synerrors = 0;
		}
 	| eoln {
		printPrompt();
	}
	| error eoln /* syntax error, skip to end of line */
		{
			synerrors = 0;
			printPrompt();
		}
	;

eoln	: EOLN
		{ 
			++lines; 
		}
	;


// you need to finish the rest of this...
line	: cmd
		{
			// cmd is a datastructure, pass it upstream
			$$ = $1;
		}
  	| cmd PIPE line
		{
			// cmd and line are both datastructures, hook them together in a linked list
			$$ = $1;
			if($3 == NULL) {
				yyerror("syntax error");
			} else if($$->outfile == NULL && $3->infile == NULL) {
				$$->outfile = "|";
				$$->next = (struct command *) MallocZ(sizeof(struct command));
				$$->next = $3;
				$3->infile = $$->outfile;
			} else {
				yyerror("illegal redirection");
			}
		}
  	;

// FINISH THIS
cmd	:WORD optargs optredirs
		{ 
			$$ = (struct command *) MallocZ(sizeof(struct command));
			$$->command = $1;
			$$->argv[0] = $1;
			int i = 1;
			while ($2 != NULL) {
				if (i == 100) {
					printf("Argument list too long\n");
					fflush(stdout);
					YYERROR;
				}
				$$->argv[i] = $2->arg;
				$2 = $2->next;
				i++;
			}
			while ($3 != NULL) {
				if ($3->redir_token == 0 && $$->infile == NULL) {
					$$->infile = $3->filename;
				} else if ($3->redir_token == 1 && $$->outfile == NULL) {
					$$->outfile = $3->filename;
				} else if ($3->redir_token == 2 && $$->outfile == NULL) {
					$$->outfile = $3->filename;
					$$->output_append = '1';
				} else if ($3->redir_token == 3 && $$->errfile == NULL) {
					$$->errfile = $3->filename;
				} else if ($3->redir_token == 4 && $$->errfile == NULL) {
					$$->errfile = $3->filename;
					$$->error_append = '1';
				} else {
					yyerror("illegal redirection");
				}
				$3 = $3->next;
			}
			
			if (debug) printf("got word");
			// make and fill node of type "struct command "
			// grab the linked list for optargs and install it in the structure
			// grab the linked list for optredir and install it in the structure		
			if (debug) printf("I found a command and it is '%s'\n", $1);
		}
	;

// FINISH THIS
// these 2 rules are for "optional arguments".  They should allow one or more "arg"s
// and assemble them into a linked list of type "struct args" and return it upstead
optargs : arg optargs
			{ 
				$$->next = $2;
			}
		|	
			{ 
				$$ = NULL; // no more args 
			}
		;
arg		: WORD
		{
			// make a node for type "struct args" and pass it upsteam
			$$ = (struct args *) MallocZ(sizeof(struct args));
			$$->arg = $1;
		}
		;


// FINISH THIS
// these 2 rules are for "optional redirection".  They should  allow one or more sets of 
// redirection commands from the rule "redir"
// and assemble them into a linked list of type "struct redir" and return it upstead
optredirs : redir optredirs
			{
				$$ = (struct redirs *) MallocZ(sizeof(struct redirs));
				$$ = $1;
				$$->next = $2;
			}
		|
			{ 
				$$ = NULL; // no more redirection 
			}
		;
// just as a possible example		
redir	: INFILE WORD
			{
				$$->redir_token = 0;  // build a data structure of type struct redirs for this and pass it upstream
				$$->filename = $2;
			}
		| OUTFILE WORD
			{
				$$->redir_token = 1;  // build a data structure of type struct redirs for this and pass it upstream
				$$->filename = $2;
			}
		
		| OUTFILE_APPEND WORD
			{
				$$->redir_token = 2;  // build a data structure of type struct redirs for this and pass it upstream
				$$->filename = $2;
			}
		| ERRFILE WORD
			{
				$$->redir_token = 3;  // build a data structure of type struct redirs for this and pass it upstream
				$$->filename = $2;

			}
		
		| ERRFILE_APPEND WORD
			{
				$$->redir_token = 4;
				$$->filename = $2;
			}
		;

%%

void
yyerror(const char *error_string, ...)
{
    va_list ap;
    int line_nmb(void);

    FILE *f = stdout;

    va_start(ap,error_string);

    ++synerrors;

    fprintf(f,"Error on line %d: ", lines + 1);
    vfprintf(f,error_string,ap);
    fprintf(f,"\n");
    va_end(ap);
}